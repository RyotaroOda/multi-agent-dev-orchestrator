
# マルチエージェントによる Webアプリ開発自動化 企画書（ブラッシュアップ版 / v0.2）

## 0. エグゼクティブサマリ

本企画は、GitHub Issue を台帳（Source of Truth）として、マルチエージェントが **設計〜実装〜デバッグ〜テスト**までを自動化し、品質ゲート（必須CI）を満たした変更を **Lv2（自動マージ）**で流す仕組みを構築する。

主目的は **複数Issueの同時処理によるスループット最大化**。各Issueは 使い捨てDockerコンテナ（per Issue / per Run）で隔離実行し、ホストへの影響を最小化する。推論は LM Studio（ローカル）を基本とし、OpenHands と LM Studio の間に **LiteLLM Proxy**を置いて「ステージ別モデル切替」「観測（トークン/レイテンシ）」「運用でのモデル差し替え」を実現する。

安全性の優先順位は **A:漏えい防止 > B:ホスト保護 > C:課金回避**。この優先度を “思想” ではなく “強制力（ポリシーと実装）” として落とし込む。

---

## 1. 目的・対象

### 1.1 目的

* マルチエージェントで Webアプリ開発を自動化（設計→実装→デバッグ→テスト）
* まずは **小規模Repo** を対象にし、成功後に拡張
* **複数Issueを同時に回す（スループット型）**が主目的

  * 1 Issue内の並列は主戦場にしない

### 1.2 対象

* 技術対象：フロント + API 中心
* コードホスティング：GitHub（プライベート）
* 台帳（SoT）：GitHub Issue

### 1.3 MVPスコープ（v0.2）

**MVPで達成すること**

* Issue起点で 1 Issue / 1 Run の隔離実行が成立する
* 必須CIを満たしたPRをLv2で自動マージできる
* run_id と構造化ログで追跡可能性を確保する

**非目的（v0.2でやらないこと）**

* 1 Issue内の本格的な分散並列実行
* 自動コンフリクト解消の高度化
* 見た目重視の専用ダッシュボード開発
* マルチクラウド/マルチホストの同時運用最適化
* 本番データを使った自動検証

---

## 2. 自律性・運用レベル（Lv2）

* 自律性：**Lv2**

  * **必須CI（テスト/静的解析）が通れば自動マージ**
  * LLMは「判定者」ではなく「通るように改善する実行者」
* 人間介入：最小化（Blocked時のみ）

---

## 3. セーフティ方針

### 3.1 優先順位

1. **A：ソース/秘密情報を外部へ出さない**
2. **B：ホストを壊さない / 踏み台にしない**
3. **C：課金を避ける**

### 3.2 LLM送信ポリシー

* デフォルト：**ローカル推論（LM Studio）**
* クラウドLLM：断片的送信は許可し得るが、**強制力あるモード設計**を持つ

  * **policy:cloud-llm=deny（禁止モード）**
  * **policy:cloud-llm=allow（例外モード）**（明示ラベル or 設定でのみ許可）
* 送信する場合でも、**コード/秘密情報の送信禁止**を原則とし、違反検知を入れる（後述）

---

## 4. 脅威モデル（Threat Model）

### 4.1 想定脅威（例）

* 漏えい：プロンプト/ログ/外向き通信/PR差分/依存関係追加による情報流出
* 踏み台：コンテナからの外部スキャン・大量送信・不正通信
* 破壊：誤コマンド・無限ループ・リソース食い尽くしによるホスト影響
* 供給網：`postinstall` 等による任意コード実行、CI/テスト改ざんによる“通すだけ”のハック

### 4.2 対応方針（要点）

* **ネットワーク/ログ/秘密情報**を “デフォルトで漏れない” 設計に寄せる
* 実行は **Docker per Issue** + **権限/リソース制限**で閉じ込める
* CI抜け穴は **ルールベース検知 + 例外ラベル**でコントロールする

---

## 5. アーキテクチャ概要

### 5.1 中核コンポーネント

* **OpenHands**：オーケストレーション、状態管理、ステージ実行
* **LiteLLM Proxy**：モデルルーティング、観測（トークン/レイテンシ）、ログ制御
* **LM Studio**：ローカル推論（JITロード/TTLアンロード運用）
* **GitHub**：Issue台帳、PR/CI、必須チェックによるマージゲート
* **Runner（Apple Mac Studio M3 Ultra / メモリ512GB / self-hosted）**：Issue監視・コンテナ起動・結果反映

### 5.2 重要設計：OpenHands ⇄ LiteLLM ⇄ LM Studio（Proxy必須）

* OpenHands は概念モデルを指定（例：`reasoning` / `code` / `view`）
* LiteLLM が運用ルールで **実モデルへ解決**（差し替え可能）
* LiteLLMで **トークン/レイテンシ等の観測**を一元化

---

## 6. 実行環境要件：Docker container per Issue

### 6.0 想定ホスト環境（v0.2）

* Apple Mac Studio（M3 Ultra）
* メモリ 512GB
* self-hosted runner として運用

### 6.0.1 将来対応環境（低優先度目標）

* NVIDIA DGX Spark
* 優先度は **P2（低）** とし、v0.2の必須要件には含めない
* v0.2完了後に互換性評価と再チューニングを実施する

### 6.1 仕様

* `git worktree` は採用しない
* **Issueごとに使い捨てDockerコンテナを起動し、その中で作業**
* コンテナは **1 Issue / 1 Run** で生成・破棄（リトライは原則クリーンスタート）

### 6.2 ホスト側の責務を最小化

* ホストは以下に限定：

  * 指揮（起動/停止/状態更新）
  * 結果の受領（パッチ・テスト結果・要約）
  * PR操作（作成・更新・マージ）
* ホストFSへの直接操作は極小化（B対策）

### 6.3 コンテナの安全要件

最低限、要件として明文化する：

* 非root実行（可能な範囲で）
* リソース制限（例：CPU/メモリ/PIDs/ディスク）
* ホストマウントは禁止（やむを得ない場合は allowlist）
* 実行後の確実な掃除（**Run終了時に必ず破棄**）

  * OpenHands側の残骸が残る課題を踏まえ、掃除を要件化

---

## 7. 成果物の受け渡し方式

### 方式A（推奨）：**コンテナはpushしない**

* コンテナは以下を出力：

  * `git diff`（またはパッチファイル）
  * テスト/静的解析結果
  * ステージ要約
* ホストが：

  * GitHub App（installation token）でブランチ作成 → コミット → PR作成
* メリット：

  * GitHubトークンをコンテナに置かずに済む（Aに強い）
  * PR author を bot に固定でき、approve 主体を人間と分離しやすい
  * 事故時の被害範囲が小さい

---

## 8. ワークフロー要件（状態管理 / 復帰 / ループ対策）

### 8.1 状態ラベル（State）

* `agent:queued`：実行待ち（トリガ）
* `agent:running`：実行中（ロック）
* `agent:blocked`：停止（人間対応待ち）

### 8.2 排他：run_id ロックを強制

ラベルだけでは二重実行が起き得るため、**run_idをSoTとして残す**。

* 実行開始時に Issue へ構造化コメントを投稿し、以下を記録：

  * `run_id`
  * 起動者（runner識別子）
  * 開始時刻
  * 対象ブランチ名
* 進行中は、以後の更新が **同一run_idからのものか**確認する

  * 一致しないプロセスは停止（＝二重実行防止）

### 8.3 Blockedからの復帰

* 復帰方法：

  * `agent:retry` ラベル付与
  * Issue コメントに `/retry`
* 復帰時のデフォルト：**クリーンスタート**

  * 既存ブランチ/PRがある場合：原則クローズし新しいRunとして再実行
* 将来拡張：

  * `agent:resume`（続きから）を追加できる余地は残す（v0.2非必須）

### 8.4 無限ループ対策（Give-up閾値）

* 1 Issueあたり最大リトライ回数を設定（例：5回）
* 超過したら `agent:blocked` に遷移し、Issueに残す：

  * 失敗要約
  * 直近ログの要点
  * 人間に求める判断（仕様不足/環境不足/テスト不安定等）

---

## 9. 品質ゲート要件（CI抜け穴対策）

### 9.1 差分ルールで“ハック”検知（ルールベース）

品質エージェント + ルールで検査（LLM判定に依存しない）

**検査対象**

* テスト関連（例）：

  * `*.test.*`, `__tests__/`, `tests/` 配下の

    * 削除
    * 大量コメントアウト
    * アサーション大幅削減（粗い指標でOK）
* “スキップ/only系”の増加（推奨追加）：

  * `it.skip` / `describe.skip` / `@Disabled` / `pytest.mark.skip`
  * `it.only` 等の混入
* CI設定改変（原則禁止）：

  * `.github/workflows/*`
  * `package.json scripts` 等のテスト実行コマンド

**違反時**

* 自動で `agent:blocked`

**例外ラベル**

* `policy:allow-test-change`
* `policy:allow-ci-change`

### 9.2 CI合格条件（Lv2）

* マージ可否の最終判定は **GitHub必須ステータスチェック**
* LLMは判定者にならない（品質エージェントは改善役）

---

## 10. モデル／リソース管理要件

### 10.1 モデル常駐前提を捨てる（JITロード + TTLアンロード）

**要件**

* デフォルトは JITロード
* 一定時間未使用で TTLアンロード
* 主力モデルのみ常駐は許容（ただし常駐数は最小化可能に）
* TTL/アンロードの不具合（例：メモリ二重確保）を観測し、運用で見直し可能にする

### 10.2 並列数は固定せず「リソース連動」で動的制御

**要件**

* 同時Issue数を固定値に決め打ちしない
* 現在負荷を見て、新規Issue開始を待機/開始

**v0.2の負荷シグナル（最小）**

* LM Studio側：キュー詰まり（例：`lms ps --json` などで取得可能な指標）
* OS側：macOSメモリプレッシャ指標
* VRAM使用率がAPIで取れるか未確認のため、v0.2は **“キュー詰まり + メモリプレッシャ”**で制御する

---

## 11. モデルルーティング要件（ラベル→実モデル）

### 11.1 “モデル名固定”は禁止

* 各エージェントは **モデルラベル**を要求
* LiteLLMがそのラベルを実モデルに解決（運用で差し替え可能）

### 11.2 初期ラベル設計（v0.2）

* 統括：高度推論
* 設計：高度推論（必要なら view をサブタスク化）
* 実装：コード特化
* 品質：

  * 高度推論（レビュー/セキュリティ解釈）
  * コード特化（リファクタ/テスト補強）

---

## 12. ネットワーク／ログポリシー

### 12.1 ネットワーク（デフォルト最小許可）

* コンテナの外向き通信は **デフォルトdeny寄り**とし、必要先を allowlist 化

  * GitHub（clone/fetch/必要なAPI）
  * LiteLLM/LM Studio（ローカル/内部経路）
  * （必要なら）パッケージレジストリ ※運用で明示
* Web検索を行う場合は「検索専用経路」を設け、

  * 送信できるのは **クエリのみ**
  * **コード断片/ログ/秘密情報が混入していないか**ルールでチェックし、違反は blocked

### 12.2 ログ（内容を落とさない／落としても短期）

* 収集するもの：

  * run_id / stage / モデルラベル・実モデル名
  * トークン数 / レイテンシ
  * 主要コマンドの pass/fail
* 原則収集しないもの：

  * プロンプト本文、レスポンス本文、コード全文、秘密情報
* どうしても必要な場合：

  * ローカル限定 + 短期ローテ + マスク処理（運用で制御）

---

## 13. 可観測性要件（「何が起きているか分かる」）

各Run/各ステージ終了時に Issueへ構造化ログを残す。

**最低限**

* `run_id`
* `stage`（統括・設計・実装・品質）
* 使用モデル：

  * モデルラベル
  * 実モデル名（LiteLLM側で確定）
* 実行した主要コマンドと結果（pass/fail）
* PR URL（作成した場合）
* 次アクション（retry / blocked理由）

---

## 14. 成功指標（KPI / 運用品質）

v0.2で最低限追う：

* 24時間あたり処理Issue数（throughput）
* PR作成率 / マージ率
* blocked率（理由カテゴリ別）
* 平均run時間（ステージ別）
* リトライ回数分布（give-up超過の頻度）

---

## 15. スコープ（v0.2）と非スコープ

### v0.2でやること（スコープ）

* Issueトリガ（`agent:queued`）→ run_id排他 → Docker per Issue 実行
* OpenHands + LiteLLM + LM Studio 経路
* ステージ分割（統括・設計・実装・品質）
* ルールベースの差分検知（テスト/CI改変の抜け穴対策）
* 動的並列制御（キュー詰まり + メモリプレッシャ）
* 構造化ログ（Issueコメント）

### v0.2でやらないこと（非スコープ）

* 1 Issue内の高度な並列実行（本格的な分散タスク）
* 自動コンフリクト解消の高度化（原則blockedへ）
* フル機能の見た目重視UI（必要最小の可視化に留める）

---

## 付録A：ラベル一覧（案）

### 状態

* `agent:queued`
* `agent:running`
* `agent:blocked`
* `agent:retry`

### ポリシー例外

* `policy:allow-test-change`
* `policy:allow-ci-change`
* `policy:cloud-llm=allow` / `policy:cloud-llm=deny`

---

## 付録B：構造化ログ（Issueコメント）スキーマ例

```json
{
  "run_id": "2026-02-10T12:34:56Z-issue1234-001",
  "stage": "implementation",
  "models": {
    "label": "code",
    "resolved": "lmstudio/model-x.y"
  },
  "commands": [
    {"cmd": "pnpm test", "result": "fail", "summary": "2 failing tests"}
  ],
  "artifacts": {
    "patch": "attached-or-link",
    "pr_url": "https://github.com/.../pull/123"
  },
  "next_action": {
    "state": "retry",
    "reason": "CI failed: flaky test suspected"
  }
}
```
