# エージェントアーキテクチャ仕様書 v0.2

## 1. 目的

本仕様書は「開発者は1つの対話エージェント（PM）とのみ会話し、裏側でオーケストレーターがタスク分解して各専門エージェント（ロール）に実行させる」ための **エージェントアーキテクチャ**を定義する。

本仕様は、次の前提と整合するように設計する。

* 台帳（Source of Truth）は **GitHub Issue**
* 起動は `agent:queued` ラベル
* 実行は Issue ごとの隔離環境（例：使い捨てコンテナ）で行う
* 推論は **LM Studio**（ローカル）を基本とし、**LiteLLM Proxy** を介してルーティング/計測する
* セキュリティ優先度：**A 漏えい防止 > B ホスト保護 > C 課金回避**

---

## 2. スコープ

### 2.1 本仕様に含むもの

* エージェント（ロール）構成と責務
* PM（単一対話窓口）→ オーケストレーター → 実行ロールへの分担方式
* タスク分解（DAG）モデルと、ロール切替の実行モデル
* コンテキスト（記憶）管理の保存先とフォーマット
* モデルルーティング（ラベル→実モデル）と、タスク別のモデル選択
* ツール権限（tool scope）と安全制約の設計
* エージェント間の入出力・ログ（構造化）フォーマット

### 2.2 本仕様に含まないもの

* CI/CDやDocker設定の詳細（別仕様）
* GitHub Apps / Token 管理の詳細（別仕様）
* UIの見た目（別仕様）
* 依存ライブラリ更新方針（別仕様）

---

## 3. 用語

* **Developer**：人間の開発者（利用者）
* **PM Agent**：Developer と会話する唯一の対話エージェント
* **Orchestrator**：Issue を読み、タスク分解し、実行ロールを指揮する制御主体
* **Role Agent**：専門職のロール（設計/実装/品質など）。Developer と直接会話しない
* **Agent Runner**：タスクを実行するランタイム（OpenHands 等）。ロール/モデル/権限を切替えて実行する
* **Model Label**：`reasoning` `code` `view` 等の概念モデル名（実モデル固定は禁止）
* **Resolved Model**：LiteLLM が最終的に選んだ実モデル名
* **Tool Scope**：ロールに許可される操作の集合（例：read_repo/write_code/run_tests/github_write）
* **Spec Block**：Issue に保存される構造化仕様（SoT）
* **Run**：1 Issue の 1 回の処理単位（`run_id` で識別）

---

## 4. 設計原則

1. **Single Conversational Agent**

   * Developer との対話は PM Agent のみに限定する
   * 他ロールは “実行者” とし、Developer へ質問を直接投げない

2. **SoT First**

   * 会話の結論は必ず Issue の Spec Block に落とし込む
   * Orchestrator は Spec Block のみを権威として参照する

3. **Least Privilege**

   * ロールごとに Tool Scope を最小化し、安全境界を明確にする

4. **Deterministic-ish Outputs**

   * ロールは「入力→出力」を固定し、後続工程が機械的に処理できる形に揃える

5. **Role Switching over Multi-Process**

   * v0.2 ではロールを“別プロセス”にせず、Agent Runner が **ロールプロンプトを切替**えて実行する（実装簡素化・一貫性優先）
   * 将来、必要に応じてマルチプロセス化できる拡張点を残す

---

## 5. コンポーネント構成

### 5.1 PM Agent

**責務**

* Developer の自然文要求を、構造化された Spec Block に変換する
* 仕様の曖昧さを解消するための追加質問（最小限）を行う
* 仕様確定後、Issue を実行可能状態へ遷移させる（例：`agent:queued` 付与）

**禁止事項**

* コードベース全体を長文貼付して外部へ送信するような行為（A優先）
* 実装/テストの“直接実行”は行わない（責務分離）

**主要アウトプット**

* Spec Block（YAML/JSON）
* Decisions/Changelog の更新

---

### 5.2 Orchestrator

**責務**

* `agent:queued` 検知 → `run_id` 付与 → ロック（排他）取得
* Spec Block を入力として **タスクDAG** を生成
* タスクを順次（または安全な範囲で）実行し、成果物を PR/Issue に反映
* 失敗時のリトライ管理、上限到達時の blocked 化

**重要要件**

* **二重実行防止**：`agent:running` ラベルだけに依存せず、`run_id` をSoTとして保存し照合する
* **ロールと権限の強制**：タスクごとに Model Label / Tool Scope を必ず指定し、Runner に適用させる

---

### 5.3 Agent Runner

**責務**

* Orchestrator から与えられたタスク定義に従い、以下を切替えて実行する

  * Role Prompt（ロールのシステム指示）
  * Model Label（`reasoning`/`code`/`view`）
  * Tool Scope（許可操作）
  * 作業ディレクトリ（Run単位の隔離）

**備考**

* v0.2 はロール切替方式を採用し、同一ワークスペース内で作業を継続可能とする

---

### 5.4 Role Agent 群

v0.2 では “固定エージェント常駐” ではなく、**ロール定義の集合**として実装する。

ロールは以下のステージに属する。

* 統括：context_manager / resource_controller（内部ロール）
* 設計：architecture / schema_api / ui_ux
* 実装：frontend / backend / database
* 品質：test_dev / reviewer / security / refactor
* 運用：ops / user_simulator（v0.2ではオプション扱い）

---

## 6. 実行モデル

### 6.1 処理の起点

* Orchestrator は `agent:queued` の付与をトリガに Run を開始する

### 6.2 排他制御

* Run 開始時に Issue へ **Run Header** を書き込み、`run_id` を確定させる
* 以後、Orchestrator は「Issue上の `run_id` と自分の `run_id` が一致する場合のみ」処理を継続する

---

## 7. データモデル

### 7.1 Issue Spec Block

Issue に以下のブロックを保持する（Markdown内に埋め込み）。

#### Spec Block 例

```yaml
spec_version: 0.2
title: "..."
problem: "..."
goals:
  - "..."
non_goals:
  - "..."
acceptance_criteria:
  - "..."
constraints:
  - "CI設定変更は禁止（例外ラベルが必要）"
  - "秘密情報を外部送信しない"
tech_notes:
  frontend: "..."
  backend: "..."
api_notes:
  - "PATCH /api/profile"
test_plan:
  - "unit: ..."
  - "integration: ..."
priority: "P1"
```

**要件**

* PM Agent は Spec Block を必ず生成・更新する
* Orchestrator は Spec Block のみを入力として扱い、会話ログ依存を避ける

---

### 7.2 Run Header

```yaml
run_id: "2026-02-10T12:34:56Z-issue123-001"
runner: "macstudio-01"
status: "running"
started_at: "2026-02-10T12:34:56Z"
```

---

### 7.3 Task DAG

Orchestrator はタスクを DAG（依存関係付き）で表現する。

#### Task 定義（概念）

```json
{
  "task_id": "design_api",
  "stage": "design",
  "role": "schema_api",
  "deps": ["design_arch"],
  "model_label": "reasoning",
  "tool_scope": ["read_repo", "write_docs"],
  "inputs": ["spec", "repo_scan"],
  "outputs": ["docs/api.md", "openapi.yaml"],
  "retry_policy": {"max_retries": 2},
  "timeout_sec": 1800
}
```

**要件**

* 全タスクは `model_label` と `tool_scope` を必須とする（未指定は実行不可）
* `outputs` は後続タスクが参照できる命名規約に従う

---

### 7.4 Task Log

各タスク完了時、Issueに構造化ログを残す。

```json
{
  "run_id": "...",
  "task_id": "design_api",
  "stage": "design",
  "role": "schema_api",
  "model": {"label": "reasoning", "resolved": "lmstudio/xxx"},
  "result": "success",
  "artifacts": ["docs/api.md"],
  "commands": [{"cmd": "pnpm test", "result": "skip"}],
  "notes": "..."
}
```

**ログ方針**

* プロンプト本文、応答本文、コード全文をログに残さない（必要ならマスク/要約）

---

## 8. モデルルーティング仕様

### 8.1 Model Label

* ロールは **実モデル名を指定してはいけない**
* タスクは必ず Model Label を指定する
  例：`reasoning` / `code` / `view` / `light`

### 8.2 解決

* LiteLLM Proxy が Model Label → Resolved Model に解決する
* 解決結果（Resolved Model）は Task Log に必ず記録する

---

## 9. Tool Scope 仕様

### 9.1 基本スコープ

* `read_repo`：リポジトリ参照
* `write_code`：コード変更
* `write_docs`：ドキュメント変更
* `run_tests`：テスト実行
* `run_lint`：静的解析実行
* `github_read`：Issue/PR参照
* `github_write`：Issueコメント/ラベル/PR操作（権限が必要）
* `net_allowlisted`：許可リスト先への通信のみ
* `secrets_none`：秘密情報へアクセス禁止（デフォルト）

### 9.2 ロール別デフォルトスコープ

* PM：`github_read`, `github_write`, `write_docs`（原則 `read_repo` は最小）
* architecture：`read_repo`, `write_docs`
* schema_api：`read_repo`, `write_docs`
* ui_ux：`write_docs`（必要時のみ `read_repo`）
* frontend/backend/database：`read_repo`, `write_code`, `run_tests`
* test_dev：`read_repo`, `write_code`, `run_tests`
* reviewer/security/refactor：`read_repo`, `write_code`（必要なら）`run_tests`
* ops：デフォルト無効（例外ラベル時のみ）
* user_simulator：`run_tests`（E2Eがある場合）

---

## 10. ロール定義

以下は v0.2 の “最低限成立” を前提にした定義。ロールは追加可能。

### 10.1 Orchestrator ロール群

#### context_manager

* 入力：会話要約、Spec変更、Runログ
* 出力：Decisions/Changelog更新、README/設計書の更新案
* model_label：`reasoning`
* tool_scope：`github_write`, `write_docs`

#### resource_controller

* 入力：LM Studioキュー指標、OSメモリ圧迫指標
* 出力：開始/待機判断、同時実行枠の調整
* model_label：`light`
* tool_scope：原則なし（読み取りのみ）

---

### 10.2 設計ステージ

#### architecture

* 目的：構成方針、ディレクトリ構成、主要技術選定、設計方針
* 出力：`docs/architecture.md`（またはIssueコメントの設計サマリ）
* model_label：`reasoning`
* tool_scope：`read_repo`, `write_docs`

#### schema_api

* 目的：API/スキーマ、フロント・バックの接続仕様を確定
* 出力：`docs/api.md` / `openapi.yaml`（任意）
* model_label：`reasoning`
* tool_scope：`read_repo`, `write_docs`

#### ui_ux

* 目的：画面フロー、アクセシビリティ、コンポーネント指針
* 出力：`docs/ui.md` / ワイヤーフロー（テキスト）
* model_label：`view`（必要な場合）または `reasoning`
* tool_scope：`write_docs`

---

### 10.3 実装ステージ

#### frontend

* 目的：UI実装、状態管理、API接続
* 出力：コード変更、ローカルテスト結果
* model_label：`code`
* tool_scope：`read_repo`, `write_code`, `run_tests`

#### backend

* 目的：API実装、認証認可、ビジネスロジック
* 出力：コード変更、ローカルテスト結果
* model_label：`code`
* tool_scope：`read_repo`, `write_code`, `run_tests`

#### database

* 目的：マイグレーション、クエリ、スキーマ整合
* 出力：マイグレーション、テスト
* model_label：`code`
* tool_scope：`read_repo`, `write_code`, `run_tests`

---

### 10.4 品質ステージ

#### test_dev

* 目的：単体/結合/E2Eテストの追加・修正
* 出力：テストコード、CI通過に寄与
* model_label：`code`
* tool_scope：`read_repo`, `write_code`, `run_tests`

#### reviewer

* 目的：論理チェック、規約、差分妥当性
* 出力：指摘リスト、修正提案
* model_label：`reasoning`
* tool_scope：`read_repo`

#### security

* 目的：脆弱性/権利/ライセンス/生成物リスクの確認
* 出力：懸念点と対策案、blocked推奨の根拠
* model_label：`reasoning`
* tool_scope：`read_repo`

#### refactor

* 目的：重複削減、性能改善、保守性向上（ただし過剰最適化は禁止）
* 出力：リファクタ差分、テスト結果
* model_label：`code`
* tool_scope：`read_repo`, `write_code`, `run_tests`

---

### 10.5 運用ステージ

#### ops

* v0.2は原則オフ。例外ラベルがある場合のみ動作
* model_label：`reasoning` or `code`
* tool_scope：最小（CIやIaCはデフォルト禁止）

#### user_simulator

* 目的：特定ペルソナでの操作観点をチェックし、不具合を報告
* 出力：手順＋期待結果＋観測結果
* model_label：`reasoning`
* tool_scope：`run_tests`（E2Eがあれば）

---

## 11. タスク分解方針

### 11.1 v0.2の分解はテンプレ優先

* スタック判定（repo_scan）→ 設計 → 実装 → 品質 の既定テンプレに当てはめる
* Specに応じてタスクを省略/追加する
  例：UIのみなら schema_api/backend をスキップ

### 11.2 依存の基本ルール

* 設計（architecture/schema_api）完了前に実装を開始しない
* 品質は実装完了後に開始
* “運用（ops）”は例外ラベルがない限り開始しない

---

## 12. 安全要件（エージェントアーキテクチャ視点）

### 12.1 データ漏えい防止

* PM Agent は Spec Block に必要最小限の情報のみを記載する
* Task Log は要約中心で、機密を含む原文を残さない
* Model Label の設計により、外部送信を行う可能性のある経路はデフォルト無効とする（別仕様で強制）

### 12.2 変更の安全制約

* “品質ゲート回避”を目的とした差分が疑われる場合、品質ロールが blocked を推奨し、Orchestrator が最終判断する
  例：テスト削除、CI設定改変、skip/only混入など

### 12.3 権限の分離

* ロールは Tool Scope の範囲でのみ動作し、Runner は強制する
* Orchestrator は「例外ラベルがある時だけ」危険スコープを解放できる

---

## 13. 受け入れ基準

本アーキテクチャは次を満たすこと。

1. Developer は PM Agent 以外と会話しない
2. Orchestrator は Issue 上の Spec Block を唯一の仕様入力として実行できる
3. すべてのタスクは `model_label` と `tool_scope` が明示され、Runner が強制する
4. `run_id` により二重実行が防止される
5. 各タスクの結果が Issue に構造化ログとして残り、何が起きたか追跡できる

---

## 14. 拡張点

* マルチプロセス化：ロールごとに独立ワーカー化（メッセージキュー導入）
* `agent:resume`：途中状態（中間成果物）からの再開
* より厳格なポリシーエンジン：差分/ネット/ログ/外部送信を統合的に判定
* UIダッシュボード：Run/Task 状態の一覧表示（SoTはIssueのまま）

